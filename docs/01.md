# Fortran90 補習資料 第1回

## はじめに

*   この資料のプログラムは、基本的に（コピー＆ペーストではなく）**自分で打ち込んで実行**してみてください。見てすぐに理解できる場合は、それでも構いません。
*   プログラムの後には簡単な説明があります。演習がある場合は、ぜひ挑戦してみてください。

## プログラムの基本的な実行方法

1.  **ファイル作成:** プログラムをテキストエディタで作成し、`output.f90` のような名前で保存します（ファイル名は任意ですが、拡張子は `.f90` または `.f` とすることが一般的です）。
2.  **コンパイル:** ターミナル（またはコマンドプロンプト）で以下のコマンドを実行し、プログラムを機械語に翻訳（コンパイル）します。`gfortran` はFortranコンパイラの一例です。
    ```bash
    gfortran output.f90
    ```
    エラーがなければ、`a.out`（Linux/macOS）または `a.exe`（Windows）という実行ファイルが生成されます。
3.  **実行:** 生成された実行ファイルを以下のコマンドで実行します。
    ```bash
    ./a.out
    ```

---

## 1. 画面への出力 (print, write)

```fortran
program output
  ! この行はコメントです。実行されません。
  print*, "Hello DB"
  write(*,*) "Good-by DB" ! print*, と同じ意味です
end program output
```

**[説明]**

*   `!` から始まる行（または行の途中から `!` 以降）はコメントとなり、プログラムの実行には影響しません。説明などを記述するのに使います。
*   `print*, "メッセージ"` や `write(*,*) "メッセージ"` は、画面に文字列や変数の値を表示する命令です。`*` は書式を自動で設定するという意味です。

---

## 2. キーボードからの入力 (read)

```fortran
program input
  integer :: i  ! 整数型変数 i を宣言

  print*, " Seisu wo hitotsu irete kudasai" ! メッセージ表示
  read(*,*) i                             ! キーボードから整数を読み込み、変数 i に代入
  print*, "i= ", i                         ! 入力された i の値を表示
end program input
```

**[説明]**

*   `integer :: i` は、`i` という名前の変数が整数 (`integer`) を格納するためのものであることを宣言しています。
*   `read(*,*) i` は、キーボードからの入力を待ち、入力された値を `i` に代入します。

---

## 3. ファイルへの出力 (open, write, close)

```fortran
program output_disk
  integer :: i

  i = 5  ! 変数 i に 5 を代入

  ! ファイルを開く (ユニット番号21、ファイル名 "output.txt")
  open(21, file="output.txt")

  ! ファイル(ユニット番号21)に変数 i の値を書き込む
  write( 21, * ) i

  ! ファイルを閉じる (ユニット番号21)
  close( 21 )

end program output_disk
```

**[説明]**

*   `open(ユニット番号, file="ファイル名")` で、データを書き込むためのファイルを開きます。**ユニット番号**は、プログラム内でそのファイルを識別するための番号です（通常、5は標準入力、6は標準出力に使われるため、それ以外を選びます）。
*   `write(ユニット番号, *) データ` で、指定したユニット番号のファイルにデータを書き込みます。
*   `close(ユニット番号)` で、開いたファイルを閉じます。ファイルを閉じることで、書き込み内容が確実に保存されます。

**[演習]**

1.  上記の `output_disk` プログラムを実行してください。
2.  カレントディレクトリに `output.txt` というファイルが作成されていることを確認してください。
3.  ターミナルで以下のコマンドを実行し、ファイルの内容を表示してみましょう。
    ```bash
    cat output.txt
    ```
    ファイル内に `5` と表示されれば成功です。

---

## 4. ファイルからの入力 (open, read, close)

```fortran
program input_disk
  integer :: i

  ! ファイルを開く (ユニット番号11, ファイル名 "output.txt")
  ! 事前に output_disk プログラムで output.txt が作成されている必要があります
  open(11, file="output.txt")

  ! ファイル(ユニット番号11)からデータを読み込み、変数 i に代入
  read( 11, * ) i

  ! 読み込んだ値を画面に表示
  print*, i

  ! ファイルを閉じる (ユニット番号11)
  close( 11 )

end program input_disk
```

**[説明]**

*   前のプログラム (`output_disk`) で作成した `output.txt` からデータを読み込むプログラムです。
*   `read(ユニット番号, *) 変数` で、指定したユニット番号のファイルからデータを読み込み、指定した変数に代入します。

---

## 5. 四則演算

```fortran
program fourcalc
  integer :: i, j, k

  i = 3
  j = 4

  k = 2 * ( i - j )  ! 演算: k = 2 * (3 - 4) = -2
  print*, k

  k = i / j          ! 整数同士の割り算: k = 3 / 4 = 0 (小数点以下は切り捨て)
  print*, "k= ", k

end program fourcalc
```

**[説明]**

*   基本的な算術演算子 (`+`, `-`, `*`, `/`) を使って計算できます。
*   `integer` 型（整数）同士の割り算では、結果も `integer` となり、小数点以下は切り捨てられます。 `3 / 4` は `0.75` ではなく `0` になります。

---

## 6. 文字列 (character)

```fortran
program character
  character(len=10) :: ca, cb  ! 長さ10の文字列変数 ca, cb を宣言

  ca = "a xyz"          ! 文字列を代入 (右側は空白で埋められる)
  cb = "543" // "2a"     ! "//" で文字列を連結: "5432a"

  print*, ca, cb         ! 変数 ca と cb の内容を表示

end program character
```

**[説明]**

*   `character(len=長さ) :: 変数名` で、指定した長さを持つ文字列変数を宣言します。
*   文字列はダブルクォーテーション (`"`) またはシングルクォーテーション (`'`) で囲みます。
*   `//` 演算子を使って文字列同士を連結できます。
*   宣言した長さより短い文字列を代入した場合、残りは空白（スペース）で埋められます。`ca` には `"a xyz     "` が格納されます。

---

## 7. 条件分岐 (if)

```fortran
program ifif
  integer :: i

  print*, "Please input seisu"
  read(*,*) i

  if ( i == 1 ) then      ! i が 1 と等しい場合
     print*, "ichi"
  elseif ( i == 2 ) then  ! そうではなく、i が 2 と等しい場合
     print*, "ni"
  else                    ! 上記のいずれでもない場合
     print*, "hoka"
  endif                   ! if文の終わり

end program ifif
```

**[説明]**

*   `if (条件式) then ... endif` で、条件によって処理を分岐させることができます。
*   条件を追加する場合は `elseif (条件式) then ...` を使います。
*   どの条件にも当てはまらない場合の処理は `else ...` に記述します。
*   **重要:** 等しいことを比較する演算子は `=` ではなく `==` を使います。他にも比較演算子があります (`>`, `<`, `>=`, `<=`, `/=` (等しくない))。

**[演習]**

*   上のプログラムを修正し、`i` が `2` に等しい場合は `"ni"`、`2` より大きい場合は `"ni_ijyo"` と表示するように変更してみましょう。（ヒント: `elseif` の条件を `i >= 2` に変更し、その後の `else` を調整または削除します。）

   ```fortran
   program ifif_modified
     integer :: i
     print*, "Please input seisu"
     read(*,*) i
     if ( i == 1 ) then
        print*, "ichi"
     elseif ( i >= 2 ) then ! iが2以上の場合
        print*, "ni_ijyo"   ! このように変更
     ! else                ! 1未満の場合は何も表示しないなら else は不要
     !    print*, "hoka"
     endif
   end program ifif_modified
   ```

---

## 8. 繰り返し (do ループ)

```fortran
program dodo
  integer :: i, j

  j = 0
  do i = 1, 5   ! i を 1 から 5 まで 1ずつ増やしながら繰り返す
    j = j + i     ! j に i を加算していく
    print*, i, j  ! 各ステップでの i と j の値を表示
  enddo         ! doループの終わり

end program dodo
```

**[説明]**

*   `do 変数 = 開始値, 終了値` から `enddo` までの間の処理を繰り返します。
*   デフォルトでは、ループ変数は1ずつ増加します。 `do i = 1, 5, 2` のように書くと、ステップ（増分）を2に指定できます（この場合 i は 1, 3, 5 と変化）。
*   `do` ループは入れ子（ネスト）にして使うこともできます。

```fortran
! 入れ子の例
program nested_do
  integer :: i, j
  do i = 1, 2
    do j = 1, 3
      print*, "i=", i, " j=", j
    enddo
  enddo
end program nested_do
```

---

## 9. 1次元配列 (array)

```fortran
program array1
  integer :: k(4)  ! 要素数4の整数型配列 k を宣言 (k(1), k(2), k(3), k(4))

  k(1) = 11       ! 1番目の要素に 11 を代入
  k(2) = 12       ! 2番目の要素に 12 を代入
  k(3) = 13       ! 3番目の要素に 13 を代入
  k(4) = k(3) + 1 ! 4番目の要素に k(3) + 1 (つまり 14) を代入

  print*, k(:)    ! 配列 k の全要素を表示 (k(1)からk(4)まで)

end program array1
```

**[説明]**

*   `型 :: 配列名(要素数)` で、同じ型のデータを複数格納できる**配列**を宣言します。科学技術計算では非常に重要です。
*   `配列名(インデックス)` で、個々の要素にアクセスします。Fortranの配列インデックスは、デフォルトで `1` から始まります。
*   `配列名(:)` で、配列のすべての要素をまとめて扱うことができます（配列セクション）。

**[演習]**

*   上記の `array1` プログラムを修正し、配列 `k` の大きさを4から5に変更してください。
*   そして、5番目の要素 `k(5)` に `-5` を代入し、全要素を表示するように変更してみましょう。

   ```fortran
   program array1_modified
     integer :: k(5)  ! 要素数を5に変更
     k(1) = 11
     k(2) = 12
     k(3) = 13
     k(4) = k(3) + 1
     k(5) = -5       ! 5番目の要素に -5 を代入
     print*, k(:)    ! 全要素 (k(1) から k(5)) を表示
   end program array1_modified
   ```

---

## 10. 2次元配列

```fortran
program array2
  integer :: k( 2, 3 )  ! 2行3列の整数型配列 k を宣言

  ! 1行目の要素を設定
  k( 1, 1 ) = 11
  k( 1, 2 ) = 12
  k( 1, 3 ) = 13

  ! 2行目の全要素に、1行目の対応する要素の2倍を代入
  ! k(2,:) は k(2,1), k(2,2), k(2,3) を意味する
  k( 2, : ) = k( 1, : ) * 2

  ! 2行目の要素を個別に表示
  print*, k( 2, 1 ), k( 2, 2 ), k( 2, 3 )

  ! 配列全体の要素を表示 (注意: 出力順序)
  print*, k(:,:)

end program array2
```

**[説明]**

*   `型 :: 配列名(行数, 列数)` で、2次元配列を宣言します。
*   `k(行, 列)` で要素にアクセスします。
*   `k(行, :)` で指定した行のすべての列要素を、`k(:, 列)` で指定した列のすべての行要素をまとめて扱えます。
*   **重要:** `print*, k(:,:)` のように2次元配列全体を表示すると、要素は `k(1,1), k(2,1), k(1,2), k(2,2), k(1,3), k(2,3)` の順（**列優先順序**、Column-major order）で出力されます。これはC言語など多くの言語の行優先順序（Row-major order）とは異なります。

---

## 11. サブルーチン (subroutine)

まず、サブルーチンを使わない簡単なプログラムを見てみましょう。

```fortran
program nosub
  integer :: i, j

  print*, "input an integer"
  read( *, * ) i  ! 整数を入力

  j = i * 2       ! 入力値を2倍して j に代入

  print*, i, j    ! 元の値と2倍した値を表示
end program nosub
```

次に、上のプログラムの「入力値を2倍する」部分を**サブルーチン**として独立させた例を示します。

**[演習]**

1.  まず、`nosub.f90` という名前で上のプログラムを保存・実行してみましょう。
2.  次に、ターミナルで以下のコマンドを実行し、ファイルをコピーします。
    ```bash
    cp nosub.f90 sbrtn.f90
    ```
3.  コピーしてできた `sbrtn.f90` を以下のように書き換えてください。

```fortran
! メインプログラム
program sbrtn
  integer :: i, j

  print*, "input an integer"
  read( *, * ) i

  ! サブルーチン 'bai' を呼び出す
  ! i の値をサブルーチンに渡し (入力)、計算結果を j で受け取る (出力)
  call bai( i, j )

  print*, i, j    ! 元の値とサブルーチンで計算された値を表示
end program sbrtn

! サブルーチン 'bai' の定義
! ii で値を受け取り、計算結果を jj に代入して返す
subroutine bai( ii, jj )
  integer, intent(in)  :: ii  ! ii は入力専用 (値を受け取るだけ)
  integer, intent(out) :: jj  ! jj は出力専用 (値を返すため)

  jj = ii * 2  ! 受け取った値を2倍して jj に代入
end subroutine bai
```

**[説明]**

*   `subroutine 名前(引数リスト) ... end subroutine 名前` で、特定の処理をまとめたサブルーチンを定義します。
*   メインプログラム（`program ... end program`）から `call サブルーチン名(引数リスト)` でサブルーチンを呼び出して実行します。
*   引数を使って、メインプログラムとサブルーチン間でデータの受け渡しを行います。
    *   `intent(in)`: サブルーチンが値を受け取るだけで、変更しない引数。
    *   `intent(out)`: サブルーチンが値を計算・設定して、呼び出し元に返す引数。
    *   `intent(inout)`: サブルーチンが値を受け取り、変更して返す引数（省略した場合のデフォルトに近い）。
*   この例のように処理が単純な場合はサブルーチンのメリットは少ないですが、プログラムが大規模になり、複雑な処理がいくつも出てくる場合に、処理をサブルーチンに分割することで、プログラム全体の構造が分かりやすくなり、開発や修正が容易になります。

---

## 12. 変数型と書式付き出力

```fortran
program define
  integer :: i            ! 整数型
  real :: f               ! 実数型 (小数点を含む数)
  character(LEN=5) :: c   ! 長さ5の文字型

  i = 15
  f = 10.0
  c = "abcde"

  ! 書式指定なしで表示 (コンパイラが自動で調整)
  print*, i, f, c

  ! 書式を指定して表示
  ! i5: 整数を5桁で表示
  ! f10.3: 実数を全体10桁、小数点以下3桁で表示
  ! a: 文字列をそのまま表示 (ここでは長さ5で)
  write(*, '(i5, f10.3, a)') i, f, c

end program define
```

**[説明]**

*   Fortranでよく使われる基本的なデータ型には `integer` (整数)、`real` (実数)、`character` (文字) があります。
*   `write(*, フォーマット文字列) 変数リスト` を使うと、出力の書式（桁数、小数点以下の桁数など）を細かく制御できます。
*   フォーマット文字列は `'()' ` の中に記述します。
    *   `i`：整数 (`i5` は5桁)
    *   `f`：実数 (`f10.3` は全体10桁、小数点以下3桁)
    *   `a`：文字 (`a` または `a5` など)
    *   `x`：空白 (`10x` は10個の空白)
    *   `/`：改行

---

## 13. 書式付き出力の例と `implicit none`

```fortran
program formatprint
  implicit none  ! 変数宣言を強制する (推奨)
  real :: f

  f = 10.0

  ! 書式指定なし
  write(*,*) f

  ! 書式指定あり (全体10桁、小数点以下3桁)
  write(*,'(f10.3)') f

end program formatprint
```

**[説明]**

*   `implicit none` をプログラム（またはサブルーチン）の最初に書くと、**すべての変数を明示的に宣言する必要**があります。宣言されていない変数を使おうとするとコンパイルエラーになります。これにより、タイプミスによる予期せぬバグを防ぐことができるため、**`implicit none` を使うことが強く推奨されます**。
*   `write(*,'(f10.3)') f` は、変数 `f` の値を、全体で10桁、小数点以下を3桁で表示します。`10.0` は `    10.000` のように表示されます（先頭に空白がいくつか付きます）。

---

## 14. 組み込み関数 (Intrinsic Functions)

Fortranには、よく使われる計算を行うための**組み込み関数**が多数用意されています。

```fortran
program func
  implicit none
  real :: a

  a = 3.14159
  print*, "cos(pi) =", cos( a )          ! 余弦 (cosine)

  a = 2.7
  print*, "log(2.7) =", log( a )         ! 自然対数 (natural logarithm)

  a = 3.0
  print*, "3^2, sqrt(3) =", a**2, sqrt( a ) ! べき乗 (**), 平方根 (square root)

  a = 2.6
  print*, "int(2.6), nint(2.6) =", int( a ), nint( a )  ! 整数化(切り捨て), 四捨五入

  a = -2.6
  print*, "int(-2.6), nint(-2.6) =", int( a ), nint( a ) ! 負数の場合

  ! 指数表記 (E notation)
  a = 1.0e3   ! 1.0 * 10^3 = 1000.0
  print*, "1.0e3 =", a

  a = 5.0e-1  ! 5.0 * 10^-1 = 0.5
  print*, "5.0e-1 =", a

end program func
```

**[説明]**

*   `cos(x)`, `sin(x)`, `tan(x)`: 三角関数 (引数はラジアン)
*   `log(x)`: 自然対数
*   `log10(x)`: 常用対数
*   `exp(x)`: 指数関数 (e^x)
*   `sqrt(x)`: 平方根
*   `abs(x)`: 絶対値
*   `int(x)`: 実数を整数に変換 (小数点以下切り捨て)
*   `nint(x)`: 実数を最も近い整数に丸める (四捨五入に近い)
*   `real(i)`: 整数を実数に変換
*   `mod(a, p)`: a を p で割った余り
*   数値は `1.0e3` (1.0 × 10³) や `5.0e-1` (5.0 × 10⁻¹) のような指数表記で記述することもできます。
