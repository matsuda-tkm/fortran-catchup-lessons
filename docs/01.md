# Fortran90 補習資料 第1回

## はじめに

*   この資料のプログラムは、基本的に（コピー＆ペーストではなく）**自分で打ち込んで実行**してみてください。見てすぐに理解できる場合は、それでも構いません。
*   プログラムの後には簡単な説明があります。演習がある場合は、ぜひ挑戦してみてください。

## プログラムの基本的な実行方法

1.  **ファイル作成:** プログラムをテキストエディタで作成し、`output.f90` のような名前で保存します（ファイル名は任意ですが、拡張子は `.f90` または `.f` とすることが一般的です）。
2.  **コンパイル:** ターミナル（またはコマンドプロンプト）で以下のコマンドを実行し、プログラムを機械語に翻訳（コンパイル）します。`gfortran` はFortranコンパイラの一例です。
    ```bash
    gfortran output.f90
    ```
    エラーがなければ、`a.out`（Linux/macOS）または `a.exe`（Windows）という実行ファイルが生成されます。
3.  **実行:** 生成された実行ファイルを以下のコマンドで実行します。
    ```bash
    ./a.out
    ```

---

## 1. 画面への出力 (print, write)

```fortran
program output
  ! この行はコメントです。実行されません。

  ! "Hello DB" を標準出力に表示
  print *, "Hello DB"

  ! print*, と同じ意味です
  write(*,*) "Good-by DB"

end program output
```

**[説明]**

*   `!` から始まる行（または行の途中から `!` 以降）はコメントとなり、プログラムの実行には影響しません。説明などを記述するのに使います。
*   `print*, "メッセージ"` や `write(*,*) "メッセージ"` は、画面に文字列や変数の値を表示する命令です。`*` は書式を自動で設定するという意味です。

---

## 2. キーボードからの入力 (read)

```fortran
program input
    ! 整数型変数 i を宣言
    integer :: i

    ! ユーザに整数の入力を促す
    print *, " 整数を1つ入力してください。"
    ! ユーザからの入力を整数 i に読み込む
    read(*,*) i
    ! 入力された整数を表示
    print *, "入力された整数は", i, "です。"

end program input
```

**[説明]**

*   `integer :: i` は、`i` という名前の変数が整数 (`integer`) を格納するためのものであることを宣言しています。
*   `read(*,*) i` は、キーボードからの入力を待ち、入力された値を `i` に代入します。

---

## 3. ファイルへの出力 (open, write, close)

```fortran
program output_disk
    integer :: i

    ! 変数 i に 値 5 を代入
    i = 5

    ! ファイルを開く (ユニット番号 21, ファイル名 "output.txt")
    open(unit=21, file="output.txt")

    ! ファイル (ユニット番号 21) に i の値を書き込む
    write(unit=21, fmt=*) i

    ! ファイルを閉じる (ユニット番号 21)
    close(unit=21)

end program output_disk
```

**[説明]**

*   `open(ユニット番号, file="ファイル名")` で、データを書き込むためのファイルを開きます。**ユニット番号**は、プログラム内でそのファイルを識別するための番号です（通常、5は標準入力、6は標準出力に使われるため、それ以外を選びます）。
*   `write(ユニット番号, *) データ` で、指定したユニット番号のファイルにデータを書き込みます。
*   `close(ユニット番号)` で、開いたファイルを閉じます。ファイルを閉じることで、書き込み内容が確実に保存されます。

**[演習]**

1.  上記の `output_disk` プログラムを実行してください。
2.  カレントディレクトリに `output.txt` というファイルが作成されていることを確認してください。
3.  ターミナルで以下のコマンドを実行し、ファイルの内容を表示してみましょう。
    ```bash
    cat output.txt
    ```
    ファイル内に `5` と表示されれば成功です。

---

## 4. ファイルからの入力 (open, read, close)

```fortran
program input_disk
    integer :: i

    ! ファイルを開く (ユニット番号11, ファイル名 "output.txt")
    ! 事前に output_disk プログラムで output.txt が作成されている必要があります
    open(unit=11, file="output.txt")

    ! ファイル(ユニット番号11)からデータを読み込み、変数 i に代入
    read(unit=11, fmt=*) i

    ! 読み込んだ値を画面に表示
    print *, "Read value:", i

    ! ファイルを閉じる (ユニット番号11)
    close(unit=11)

end program input_disk
```

**[説明]**

*   前のプログラム (`output_disk`) で作成した `output.txt` からデータを読み込むプログラムです。
*   `read(ユニット番号, *) 変数` で、指定したユニット番号のファイルからデータを読み込み、指定した変数に代入します。

---

## 5. 四則演算

```fortran
program fourcalc
    ! 変数の宣言
    integer :: i, j, k

    ! 値の代入
    i = 3
    j = 4

    ! 演算: k = 2 * (3 - 4) = -2
    k = 2 * (i - j)
    print *, "k= ", k

    ! 整数同士の割り算: k = 3 / 4 = 0 (小数点以下は切り捨て)
    k = i / j
    print *, "k= ", k

end program fourcalc
```

**[説明]**

*   基本的な算術演算子 (`+`, `-`, `*`, `/`) を使って計算できます。
*   `integer` 型（整数）同士の割り算では、結果も `integer` となり、小数点以下は切り捨てられます。 `3 / 4` は `0.75` ではなく `0` になります。

---

## 6. 文字列 (character)

```fortran
program character_example
  ! 長さ10の文字列変数 ca, cb を宣言
  character(len=10) :: ca, cb  

  ! 文字列を代入 (右側は空白で埋められる)
  ca = "a xyz"

  ! "//" で文字列を連結: "5432a"
  cb = "543" // "2a"

  ! 変数 ca と cb の内容を表示
  print *, ca, cb

end program character_example
```

**[説明]**

*   `character(len=長さ) :: 変数名` で、指定した長さを持つ文字列変数を宣言します。
*   文字列はダブルクォーテーション (`"`) またはシングルクォーテーション (`'`) で囲みます。
*   `//` 演算子を使って文字列同士を連結できます。
*   宣言した長さより短い文字列を代入した場合、残りは空白（スペース）で埋められます。`ca` には `"a xyz     "` が格納されます。

---

## 7. 条件分岐 (if)

```fortran
program ifif
    integer :: i

    ! 整数を入力
    print *, "Please input seisu"
    read(*, *) i

    ! 条件分岐

    ! i が 1 と等しい場合
    if (i == 1) then
        print *, "ichi"
    ! そうではなく、i が 2 と等しい場合
    elseif (i == 2) then
        print *, "ni"
    ! 上記のいずれでもない場合
    else
        print *, "hoka"
    endif

end program ifif
```

**[説明]**

*   `if (条件式) then ... endif` で、条件によって処理を分岐させることができます。
*   条件を追加する場合は `elseif (条件式) then ...` を使います。
*   どの条件にも当てはまらない場合の処理は `else ...` に記述します。
*   **重要:** 等しいことを比較する演算子は `=` ではなく `==` を使います。他にも比較演算子があります (`>`, `<`, `>=`, `<=`, `/=` (等しくない))。

**[演習]**

*   上のプログラムを修正し、`i` が `2` に等しい場合は `"ni"`、`2` より大きい場合は `"ni_ijyo"` と表示するように変更してみましょう。（ヒント: `elseif` の条件を `i >= 2` に変更し、その後の `else` を調整または削除します。）

```fortran
program ifif_modified
    integer :: i

    ! 整数を入力
    print *, "Please input seisu"
    read(*, *) i

    ! 条件分岐

    ! i が 1 と等しい場合
    if (i == 1) then
        print *, "ichi"
    ! i が 2 以上の場合
    elseif (i >= 2) then
        print *, "ni ijou"
    ! 1 未満の場合は何も表示しないので else 節は不要
    endif

end program ifif_modified
```

---

## 8. 繰り返し (do ループ)

```fortran
program dodo
    integer :: i, j

    ! j を 0 に初期化
    j = 0

    ! i を 1 から 5 まで 1 ずつ増やしながら繰り返す
    do i = 1, 5
        ! j に i を加算していく
        j = j + i
        ! 各ステップでの i と j の値を表示
        print *, i, j
    end do

end program dodo
```

**[説明]**

*   `do 変数 = 開始値, 終了値` から `enddo` までの間の処理を繰り返します。
*   デフォルトでは、ループ変数は1ずつ増加します。 `do i = 1, 5, 2` のように書くと、ステップ（増分）を2に指定できます（この場合 i は 1, 3, 5 と変化）。
*   `do` ループは入れ子（ネスト）にして使うこともできます。

```fortran
! 入れ子の例
program nested_do
    integer :: i, j

    ! i を 1 から 2 まで 1 ずつ増やしながら繰り返す
    do i = 1, 2
        ! j を 1 から 3 まで 1 ずつ増やしながら繰り返す
        do j = 1, 3
            print *, "i=", i, " j=", j
        enddo
    enddo

end program nested_do
```

---

## 9. 1次元配列 (array)

```fortran
program array1d
    ! 要素数4の整数型配列 k を宣言 (k(1), k(2), k(3), k(4))
    integer :: k(4)

    ! 1番目の要素に 11 を代入
    k(1) = 11
    ! 2番目の要素に 12 を代入
    k(2) = 12
    ! 3番目の要素に 13 を代入
    k(3) = 13
    ! 4番目の要素に k(3) + 1 (つまり 14) を代入
    k(4) = k(3) + 1

    ! 配列 k の全要素を表示 (k(1)からk(4)まで)
    print *, k(:)

end program array1d
```

**[説明]**

*   `型 :: 配列名(要素数)` で、同じ型のデータを複数格納できる**配列**を宣言します。科学技術計算では非常に重要です。
*   `配列名(インデックス)` で、個々の要素にアクセスします。Fortranの配列インデックスは、デフォルトで `1` から始まります。
*   `配列名(:)` で、配列のすべての要素をまとめて扱うことができます（配列セクション）。

**[演習]**

*   上記の `array1` プログラムを修正し、配列 `k` の大きさを4から5に変更してください。
*   そして、5番目の要素 `k(5)` に `-5` を代入し、全要素を表示するように変更してみましょう。

```fortran
program array1d_modified
    ! 要素数を 5 に変更
    integer :: k(5)

    k(1) = 11
    k(2) = 12
    k(3) = 13
    k(4) = k(3) + 1
    ! 5番目の要素に -5 を代入
    k(5) = -5

    ! 配列 k の全要素を表示 (k(1)からk(5)まで)
    print *, k(:)

end program array1d_modified
```

---

## 10. 2次元配列

```fortran
program array2d
    ! 2行3列の整数型配列 k を宣言
    integer :: k(2, 3)

    ! 1行目の要素を設定
    k(1, 1) = 11
    k(1, 2) = 12
    k(1, 3) = 13

    ! 2行目の全要素に、1行目の対応する要素の2倍を代入
    ! k(2,:) は k(2,1), k(2,2), k(2,3) を意味する
    k(2, :) = k(1, :) * 2

    ! 2行目の要素を個別に表示
    print *, k(2, 1), k(2, 2), k(2, 3)

    ! 配列全体の要素を表示 (注意: 出力順序)
    print *, k(:,:)

end program array2d
```

**[説明]**

*   `型 :: 配列名(行数, 列数)` で、2次元配列を宣言します。
*   `k(行, 列)` で要素にアクセスします。
*   `k(行, :)` で指定した行のすべての列要素を、`k(:, 列)` で指定した列のすべての行要素をまとめて扱えます。
*   **重要:** `print*, k(:,:)` のように2次元配列全体を表示すると、要素は `k(1,1), k(2,1), k(1,2), k(2,2), k(1,3), k(2,3)` の順（**列優先順序**、Column-major order）で出力されます。これはC言語など多くの言語の行優先順序（Row-major order）とは異なります。

---

## 11. サブルーチン (subroutine)

まず、サブルーチンを使わない簡単なプログラムを見てみましょう。

```fortran
program nosub
    integer :: i, j

    ! 整数を入力
    print *, "input an integer"
    read(*, *) i

    ! i の値を2倍して j に代入
    j = i * 2

    ! i と j の値を表示
    print *, i, j

end program nosub
```

次に、上のプログラムの「入力値を2倍する」部分を**サブルーチン**として独立させた例を示します。

**[演習]**

1.  まず、`nosub.f90` という名前で上のプログラムを保存・実行してみましょう。
2.  次に、ターミナルで以下のコマンドを実行し、ファイルをコピーします。
    ```bash
    cp nosub.f90 sbrtn.f90
    ```
3.  コピーしてできた `sbrtn.f90` を以下のように書き換えてください。

```fortran
! メインプログラム
program sbrtn
  integer :: i, j

  print*, "input an integer"
  read( *, * ) i

  ! サブルーチン 'bai' を呼び出す
  ! i の値をサブルーチンに渡し (入力)、計算結果を j で受け取る (出力)
  call bai( i, j )

  print*, i, j    ! 元の値とサブルーチンで計算された値を表示
end program sbrtn

! サブルーチン 'bai' の定義
! ii で値を受け取り、計算結果を jj に代入して返す
subroutine bai( ii, jj )
  integer, intent(in)  :: ii  ! ii は入力専用 (値を受け取るだけ)
  integer, intent(out) :: jj  ! jj は出力専用 (値を返すため)

  jj = ii * 2  ! 受け取った値を2倍して jj に代入
end subroutine bai
```

**[説明]**

*   `subroutine 名前(引数リスト) ... end subroutine 名前` で、特定の処理をまとめたサブルーチンを定義します。
*   メインプログラム（`program ... end program`）から `call サブルーチン名(引数リスト)` でサブルーチンを呼び出して実行します。
*   引数を使って、メインプログラムとサブルーチン間でデータの受け渡しを行います。
    *   `intent(in)`: サブルーチンが値を受け取るだけで、変更しない引数。
    *   `intent(out)`: サブルーチンが値を計算・設定して、呼び出し元に返す引数。
    *   `intent(inout)`: サブルーチンが値を受け取り、変更して返す引数（省略した場合のデフォルトに近い）。
*   この例のように処理が単純な場合はサブルーチンのメリットは少ないですが、プログラムが大規模になり、複雑な処理がいくつも出てくる場合に、処理をサブルーチンに分割することで、プログラム全体の構造が分かりやすくなり、開発や修正が容易になります。

---

## 12. 変数型と書式付き出力

```fortran
program define
    ! 整数型
    integer :: i
    ! 実数型 (小数点を含む数)
    real :: f
    ! 長さ 5 の文字型
    character(LEN=5) :: c

    i = 15
    f = 10.0
    c = "abcde"

    ! 書式指定なしで表示 (コンパイラが自動で調整)
    print*, i, f, c

    ! 書式を指定して表示
    ! i5 : 整数を5桁で表示
    ! f10.3 : 実数を全体10桁、小数点以下3桁で表示
    ! a : 文字列をそのまま表示 (ここでは長さ 5 で)
    write(*, "(i5, f10.3, a)") i, f, c

end program define
```

**[説明]**

*   Fortranでよく使われる基本的なデータ型には `integer` (整数)、`real` (実数)、`character` (文字) があります。
*   `write(*, フォーマット文字列) 変数リスト` を使うと、出力の書式（桁数、小数点以下の桁数など）を細かく制御できます。
*   フォーマット文字列は `'()' ` の中に記述します。
    *   `i`：整数 (`i5` は5桁)
    *   `f`：実数 (`f10.3` は全体10桁、小数点以下3桁)
    *   `a`：文字 (`a` または `a5` など)
    *   `x`：空白 (`10x` は10個の空白)
    *   `/`：改行

---

## 13. 書式付き出力の例と `implicit none`

```fortran
program formatted_output
    ! 変数宣言を強制する (推奨)
    implicit none
    ! 整数型
    real :: f

    f = 10.0

    ! 書式指定なし
    write(*, *) f

    ! 書式指定あり (全体10桁、小数点以下3桁)
    write(*,"(f10.3)") f

end program formatted_output
```

**[説明]**

*   `implicit none` をプログラム（またはサブルーチン）の最初に書くと、**すべての変数を明示的に宣言する必要**があります。宣言されていない変数を使おうとするとコンパイルエラーになります。これにより、タイプミスによる予期せぬバグを防ぐことができるため、**`implicit none` を使うことが強く推奨されます**。
*   `write(*,'(f10.3)') f` は、変数 `f` の値を、全体で10桁、小数点以下を3桁で表示します。`10.0` は `    10.000` のように表示されます（先頭に空白がいくつか付きます）。

---

## 14. 組み込み関数 (Intrinsic Functions)

Fortranには、よく使われる計算を行うための**組み込み関数**が多数用意されています。

```fortran
program intrinsic_functions
    implicit none
    real :: a

    ! 余弦 (cosine)
    a = 3.14159
    print *, "cos(pi) =", cos(a)

    ! 自然対数 (natural logarithm)
    a = 2.7
    print *, "log(2.7) =", log(a)

    ! 冪乗 (**), 平方根 (square root)
    a = 3.0
    print *, "3^2, sqrt(3) =", a**2, sqrt(a)

    ! 整数化 (切り捨て), 四捨五入
    a = 2.6
    print *, "int(2.6), nint(2.6) =", int(a), nint(a)

    ! 負の数の場合
    a = -2.6
    print *, "int(-2.6), nint(-2.6) =", int(a), nint(a)

    ! 指数表記 (E notation)
    a = 1.0e3
    print *, "1.0e3 =", a

    a = 5.0e-1
    print *, "5.0e-1 =", a

end program intrinsic_functions
```

**[説明]**

*   `cos(x)`, `sin(x)`, `tan(x)`: 三角関数 (引数はラジアン)
*   `log(x)`: 自然対数
*   `log10(x)`: 常用対数
*   `exp(x)`: 指数関数 (e^x)
*   `sqrt(x)`: 平方根
*   `abs(x)`: 絶対値
*   `int(x)`: 実数を整数に変換 (小数点以下切り捨て)
*   `nint(x)`: 実数を最も近い整数に丸める (四捨五入に近い)
*   `real(i)`: 整数を実数に変換
*   `mod(a, p)`: a を p で割った余り
*   数値は `1.0e3` (1.0 × 10³) や `5.0e-1` (5.0 × 10⁻¹) のような指数表記で記述することもできます。
