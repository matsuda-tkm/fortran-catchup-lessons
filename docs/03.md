# Fortran90 補習資料 第3回

## はじめに

前回まではFortranの基本的な文法を学びました。今回と次回は、基本的な内容から一歩進んで、実際の科学技術計算（特に地球物理分野など）のプログラミングで重要となるトピックを少し掘り下げて実習します。

今回は、プログラムにおけるデータの「入り口」と「出口」である、**ファイルの読み書き**、特に少し複雑になりがちな書式（フォーマット）の指定や、外部ファイル（CSVなど）の扱いについて練習しましょう。

---

## 1. 書式付きファイルへの書き出し (Formatted Output)

プログラムで計算した結果などを、人間が読めるテキストファイルとして保存する方法です。`write` 文で書式（フォーマット）を指定することで、出力するデータの見栄え（桁数、小数点以下の桁数、配置など）を制御できます。

```fortran
program format3
  implicit none
  integer :: i
  real :: a
  character(LEN=6) :: c

  i = -51
  a = 15.0 / 6.0  ! 実数同士の割り算 (結果は 2.5)
  c = "Goodby"

  ! ファイルを開く (ユニット番号 21, ファイル名 'output.txt')
  ! 'formatted': テキスト形式で書き込む
  ! 'sequential': ファイルの先頭から順に書き込む (通常のテキストファイル)
  open( 21, file='output.txt', &
       form='formatted', access='sequential' )

  ! write(ユニット番号, フォーマット指定) 変数リスト
  ! 1行目: 整数7桁、実数全体10桁小数点以下3桁、文字型
  write(21, '(i7, f10.3, a)') i, a, c

  ! 2行目: 整数2桁、整数5桁、実数全体4桁小数点以下3桁、文字型
  ! i2 (-51) や f4.3 (2.500) は指定した桁数に収まらない
  write(21, '(i2, i5, f4.3, a)') i, i, a, c

  ! 3行目: 整数5桁を2つ、指数形式(全体10桁有効数字2桁)、10文字空白、文字型(先頭3文字)
  write(21, '(2i5, e10.2, 10x, a3)') &
       i, i + 1, a, c

  ! ファイルを閉じる
  close(21)

end program format3
```

**[説明]**

*   **`open(...)` 文:**
    *   `21`: **ファイルユニット番号**。プログラム内でファイルを識別するための番号です。`read` や `write` でこの番号を使って対象ファイルを指定します。通常、`5`（標準入力=キーボード）、`6`（標準出力=画面）はシステムが使用するため、`10`～`99` などの番号を使うのが一般的です。
    *   `file='ファイル名'`: 読み書きするファイルの名前を指定します。
    *   `form='formatted'`: ファイルを**テキスト形式**で扱うことを指定します。人間がエディタなどで読める形式です。これはデフォルトの動作なので、省略可能です。
    *   `access='sequential'`: ファイルの**先頭から順に**読み書きを行うことを指定します。通常のテキストファイル操作ではこれを使います。これもデフォルトなので、省略可能です。
*   **`write(ユニット番号, フォーマット指定)` 文:**
    *   `'(...)`'`: フォーマット（書式）を指定する文字列です。
    *   **主なフォーマット編集記述子:**
        *   `Iw`: 整数 (`I`) を `w` 桁で出力します (`I7` なら7桁)。
        *   `Fw.d`: 実数 (`F`) を全体 `w` 桁、小数点以下 `d` 桁で出力します (`F10.3` なら全体10桁、小数点以下3桁)。
        *   `Ew.d`: 実数 (`E`) を指数形式（例: `0.25E+01`）で、全体 `w` 桁、有効数字 `d` 桁で出力します (`E10.2`)。
        *   `A`: 文字列 (`A`) を出力します (`A` または `Aw` のように桁数指定も可)。`A3` なら先頭3文字。
        *   `nX`: `n` 個の空白 (`X`) を挿入します (`10X` なら10個の空白)。
        *   `n(...)`: `()` 内のフォーマット指定を `n` 回繰り返します (`2I5` なら `I5, I5` と同じ)。
*   **桁数不足:**
    *   2つ目の `write` 文の `i2` では、`-51` (符号含め3文字必要) を2桁で表示しようとしています。また `f4.3` では `2.500` (ピリオド含め5文字必要) を4桁で表示しようとしています。このように指定された桁数に数値が収まらない場合、Fortranはそのフィールドを `*` (アスタリスク) で埋めて、桁が足りないことを示します。`output.txt` を確認すると `**` や `****` と表示されているはずです。

**[実習1: フォーマットの変更]**

*   上記の `format3.f90` を実行し、生成された `output.txt` の内容を確認してください。特に2行目の `*` が表示されている部分に注目しましょう。
*   `format3.f90` の2つ目の `write` 文のフォーマット指定を以下のように変更し、`*` が表示されなくなる（数値が正しく表示される）ようにしてみましょう。
    *   `i2` を `i4` に変更（例: 4桁あれば `-51` は表示できる）
    *   `f4.3` を `f8.3` に変更（例: 8桁あれば `2.500` は表示できる）
    ```fortran
    ! 変更例
    write(21, '(i4, i5, f8.3, a)') i, i, a, c
    ```
*   変更したら、再度コンパイル・実行し、`output.txt` の内容が意図通りになったか確認してください。
*   他にもフォーマット指定を自由に変更してみて、出力がどのように変わるか試してみましょう（例: `E`フォーマットを使ってみる、`X`で空白を増やしてみる）。

**[実習2: ファイルの内部表現の確認]**

作成した `output.txt` が、コンピュータのディスク上で実際にどのように保存されているかを見てみましょう。

1.  **`cat` コマンド:** まず、Linux/macOSのターミナルで以下のコマンドを実行します。
    ```bash
    cat output.txt
    ```
    これはファイルの内容をそのまま画面に表示するコマンドで、普段エディタで見るのと同じように、改行されて表示されるはずです。

2.  **`od` コマンド:** 次に、以下のコマンドを実行します。`od` (Octal Dump) はファイルの内容をバイトレベルで表示するコマンドです。`-c` オプションは、表示可能な文字はそのまま、特殊な文字（制御文字など）は特別な記法で表示します。
    ```bash
    od -c output.txt
    ```
    出力結果を見ると、`cat` で表示された各行の末尾に `\n` という文字が見えるはずです。これは**改行コード**を表す特殊なバイト（文字）です。
    ディスク上では、データは単に一列に並んで記録されています。`cat` やテキストエディタは、この `\n` を見つけると表示を改行しますが、`od -c` はそれを「改行コードという文字」として表示します。
    Fortranの `write` 文（書式付き、シーケンシャルアクセス）は、1回の `write` が終わるごとに、基本的にはこの改行コードをファイルに書き込みます。`read` 文は、この改行コードまでを1行（1レコード）としてデータを読み込みます。

---

## 2. 外部データファイル (CSV) の読み込み

Excelなどの表計算ソフトで作成・編集されたデータファイルをFortranプログラムで利用したい場面はよくあります。**CSV (Comma Separated Values)** 形式は、データをカンマ区切りで保存するシンプルなテキストファイル形式であり、多くのソフトウェアでデータの交換に使われます。

**[実習準備: CSVファイルのダウンロードと確認]**

1.  **ダウンロード:** Webブラウザで以下のURLにアクセスし、`exceldata.csv` というファイルをダウンロードして、Fortranプログラムを作成するのと同じディレクトリに保存してください。
    *   `http://www-clim.kugi.kyoto-u.ac.jp/shige/DB/exceldata.csv`
    *(注: 上記URLが将来的に有効である保証はありません。アクセスできない場合は、適当なCSVファイルを自分で作成してください。内容は以下の形式であればOKです)*
    ```csv
    年,気温
    1990,8.5
    1991,9.1
    ... (データが続く) ...
    ```

2.  **内容確認:** ターミナルで `cat` コマンドを使って、ダウンロードしたファイルの中身を確認しましょう。
    ```bash
    cat exceldata.csv
    ```
    1列目が年 (整数)、2列目がその年の3月の平均気温 (実数) になっているはずです。データがカンマ `,` で区切られていることを確認してください。

**[プログラム例: CSVファイルの読み込み]**

以下のプログラムは、ダウンロードした `exceldata.csv` ファイルを読み込み、内容を画面に表示します。

```fortran
program excel1
  implicit none
  integer :: i          ! ループカウンタ
  integer :: iy         ! 年 (Year) を格納する変数
  real :: a1           ! 気温 (Temperature) を格納する変数
  integer, parameter :: num_data = 20 ! 読み込むデータ行数

  ! CSVファイルを開く (ユニット番号 11)
  ! form='formatted', access='sequential' は省略 (デフォルト)
  open(11, file='exceldata.csv')

  ! ヘッダー行を読み飛ばす (もしあれば)
  ! read(11, *) ! この行を追加するとCSVの1行目(ヘッダー)を読み飛ばせる

  ! doループで指定した行数だけデータを読み込む
  do i = 1, num_data
    ! read(ユニット番号, *) 変数1, 変数2, ...
    ! '*' は自由書式読み込み。カンマやスペースで区切られたデータを適切に読み込む
    read(11, *) iy, a1
    ! 読み込んだデータを画面に表示
    print*, iy, a1
  enddo

  ! ファイルを閉じる
  close( 11 )

end program excel1
```

**[説明]**

*   `read(11, *) iy, a1` の `*` は、**自由書式 (List-directed input)** を意味します。これにより、ファイル中のデータがカンマ区切りであろうとスペース区切りであろうと、Fortranが適切に解釈して変数 `iy` と `a1` に値を読み込んでくれます。CSVファイルを読む際に非常に便利です。
*   もしCSVファイルの1行目に `年,気温` のようなヘッダー行がある場合、そのままでは数値として読み込めずにエラーになる可能性があります。その場合は、`do` ループの前に `read(11, *)` のようなダミーの読み込みを1行入れて、ヘッダー行を読み飛ばすテクニックが使えます（ただし、ヘッダー行の内容を読むための文字列変数を定義して `read(11,*) header_string` のように読む方がより確実です）。
*   このように工夫することで、多くのテキストベースのデータファイル（CSVを含む）をFortranプログラムで読み込むことができます。

**[応用: FortranからExcel用データを作成]**

逆に、Fortranで計算した結果をExcelなどの他のアプリケーションで使いたい場合は、最初の `format3` の例で見たような書式指定 `write` を使って、**桁を揃えたテキストファイル**を作成すると良いでしょう。各列のデータがスペースなどで区切られ、桁が揃っていれば、多くのアプリケーションで容易にインポートできます。カンマ区切りで出力したい場合は、フォーマット文字列内にカンマを含めることも可能です（例: `'(i5, ",", f8.3)'`）。

---

## 3. 【おまけ】フォーマットなし直接アクセスファイル (Unformatted Direct Access)

これまでの演習で扱ってきた**フォーマット付き (formatted)** ファイルは、数値を人間が読める文字の並び（テキスト）として記録します。例えば、整数 `123` は `'1'`, `'2'`, `'3'` という3つの文字（= 3バイト）として記録されます。実数 `123.45` は `'1'`, `'2'`, `'3'`, `'.'`, `'4'`, `'5'` の6バイトになります。

一方、コンピュータのメモリ内では、整数や実数は固定のバイト数（例えば整数なら4バイト、実数なら4バイトまたは8バイト）の**バイナリ形式**で表現されています。

大量の数値データをファイルに保存する場合、テキスト形式だとファイルサイズが大きくなることがあります。そこで、メモリ上のバイナリ表現のままファイルに記録する方法が用意されています。これが**フォーマットなし (unformatted)** ファイルです。

さらに、ファイルの特定の位置（レコード）を直接指定して読み書きする**直接アクセス (direct access)** という方法もあります。これらを組み合わせた例を見てみましょう。

```fortran
program unformat3
  implicit none
  integer :: i
  real :: a
  integer, parameter :: reclen = 8 ! 1レコードの長さ(バイト)を定義

  i = -51
  a = 15.0 / 6.0 ! (2.5)

  ! ファイルを開く (ユニット番号 21, ファイル名 'output.bin')
  open( 21, file='output.bin', &
       form='unformatted',  & ! バイナリ形式で読み書き
       access='direct',     & ! 直接アクセス (レコード番号指定)
       recl=reclen )          ! 1レコードの長さを指定 (バイト単位が多いが要確認)
                               ! integer(4バイト)+real(4バイト)=8バイトと仮定

  ! レコード番号を指定して書き込み
  ! rec=1 : 1番目のレコードに書き込む
  write( 21, rec = 1 ) i, a
  ! rec=2 : 2番目のレコードに書き込む
  write( 21, rec = 2 ) i, a

  close( 21 )
end program unformat3
```

**[説明]**

*   **`open(...)` 文:**
    *   `form='unformatted'`: データをメモリ上のバイナリ表現のまま記録します。ファイルはテキストエディタでは読めません（文字化けします）。
    *   `access='direct'`: ファイルのレコード番号を指定して直接読み書きします。シーケンシャルアクセスのように先頭から順にアクセスする必要はありません。
    *   `recl=長さ`: **レコード長**を指定します。直接アクセスファイルでは、すべてのレコードがこの固定長になります。この「長さ」の単位はコンパイラやOSに依存することがありますが、多くの場合バイト単位です。この例では、4バイト整数(`i`)と4バイト実数(`a`)を1レコードに書き込むため、合計8バイトと仮定しています。（もし実数が8バイトなら `recl=12` が必要になります）。
*   **`write(ユニット番号, rec=レコード番号)` 文:**
    *   `rec=番号` で書き込むレコードの位置を指定します。読み込む場合も `read(ユニット番号, rec=レコード番号)` とします。
*   **ファイルサイズ:** フォーマット付きファイルに比べてファイルサイズを小さくできる可能性があります。特に大きな数値や多くのデータを扱う場合に有利です。
*   **読み書き速度:** 一般的にフォーマット変換が不要なため、フォーマット付きファイルよりも高速に読み書きできる場合があります。

**[実習3: バイナリファイルの確認]**

`unformat3` プログラムを実行して `output.bin` を作成した後、`od` コマンドで中身を見てみましょう。

1.  **`od -c`:**
    ```bash
    od -c output.bin
    ```
    テキストファイルのように読める文字はほとんどなく、特殊文字や文字化けしたように見えるバイトが表示されるはずです。`\n` のような改行コードも含まれません。

2.  **`od -f` (実数として表示):**
    ```bash
    od -f output.bin
    ```
    ファイルの内容を浮動小数点数（実数）として解釈して表示しようとします。書き込んだ実数 `2.5` がどこかに見えるかもしれません（整数部分も無理やり実数として表示されます）。

3.  **`od -i` (整数として表示):**
    ```bash
    od -i output.bin
    ```
    ファイルの内容を整数として解釈して表示しようとします。書き込んだ整数 `-51` が見えるかもしれません（実数部分も無理やり整数として表示されます）。

**[使い分け]**

*   **フォーマット付き (テキスト):**
    *   人間が読み書きする必要がある場合。
    *   他のソフトウェア（Excel, Pythonスクリプトなど）とデータを交換する場合（特にCSVなど）。
    *   データ量がそれほど多くない場合。
    *   プログラムのデバッグ時（中身を確認しやすいため）。
*   **フォーマットなし (バイナリ):**
    *   大量の数値データを効率的に（ファイルサイズ、速度）保存・読み込みしたい場合。
    *   Fortranプログラム間でのみデータをやり取りする場合。
    *   ランダムアクセスが必要な場合（直接アクセスと組み合わせる）。

**慣れないうちは、扱いやすいフォーマット付き（テキスト）ファイルを使うのが良いでしょう。** 大規模なシミュレーションなどで大量のデータを扱う必要が出てきたときに、フォーマットなし（バイナリ）ファイルの使用を検討するとよいでしょう。
