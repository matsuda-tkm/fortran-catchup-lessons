# Fortran90 補習資料 第2回

## 1. 文の継続 (`&`)

1つの文が長くなり、読みやすさのために改行したい場合があります。Fortranでは、行末に `&` (アンパサンド) を付けることで、次の行に文が続くことを示します。

```fortran
program tuduki
  implicit none
  integer :: i
  i = 3
  ! 本来は改行不要だが、例示のため print 文を継続行にする
  print*, &  ! ← 行末に & を付ける
  i          ! ← 前の行からの続き
end program tuduki
```

**[説明]**

*   Fortranの1行の長さには制限があり、多くのコンパイラでは132文字が上限です。これを超える部分は無視されることがあります。
*   文の途中で改行したい場合は、改行したい行の**末尾**に `&` を記述します。
*   次の行の**行頭**にも `&` を書くスタイルもありますが、行末だけでも継続行として認識されます。

---

## 2. 暗黙の型宣言と `implicit none`

Fortranには、変数を明示的に宣言しなくても、変数名の最初の文字によって型が決まる「暗黙の型宣言」という古い仕様があります。

*   `i`, `j`, `k`, `l`, `m`, `n` で始まる変数名 → `integer` (整数) 型
*   上記以外 (a-h, o-z) で始まる変数名 → `real` (実数) 型

しかし、この機能はタイプミスによる意図しない型の変数を生み出し、バグの原因となりやすいです。

**例1: `implicit none` なし (悪い例)**

```fortran
program impli1
  ! implicit none がないため、暗黙の型宣言が有効
  integer :: i1  ! i1 は整数として宣言

  ! i1 と書くべきところを il とタイプミス
  ! l で始まるので、il は暗黙のうちに整数型変数として扱われてしまう
  il = 1         ! エラーにならず、未宣言の il に 1 が代入される

  print*, i1     ! i1 は宣言されたが値は未定義 (内容は不定)
end program impli1
```

**例2: `implicit none` あり (推奨される良い例)**

```fortran
program impli2
  implicit none  ! 暗黙の型宣言を禁止する

  integer :: i1

  ! i1 と書くべきところを il とタイプミス
  il = 1         ! il は宣言されていないため、コンパイル時にエラーとなる！

  print*, i1
end program impli2
```

**[説明]**

*   `impli1` の例では、`i1` とタイプミスした `il` が暗黙的に整数型変数として扱われ、コンパイルエラーになりません。しかし、意図した変数 `i1` には値が入らず、プログラムは期待通りに動作しません。
*   `impli2` の例では、プログラムの先頭に `implicit none` を記述しています。これにより、**すべての変数を明示的に宣言する必要**が生じます。宣言されていない `il` を使おうとすると、コンパイル時にエラーとして検出されるため、タイプミスによるバグを早期に発見できます。
*   **現代的なFortranプログラミングでは、常に `implicit none` を記述することが強く推奨されます。**

---

## 3. 定数パラメータ (`parameter` 属性)

プログラム中で値が変わらない「定数」を定義したい場合があります。特に、配列の大きさなど、複数の箇所で同じ値を使う場合に便利です。

```fortran
program para
  implicit none

  ! 整数型の定数 n を定義し、値を 2 とする
  integer, parameter :: n = 2

  ! 定数 n を使って配列の大きさを宣言
  integer :: ii( n, n ), ij( n, n )

  ! 配列全体に値を代入 (ii = 1 と書いても同じだが、こちらが推奨される)
  ii(:,:) = 1
  ij(:,:) = ii(:,:) * 2

  print*, ij  ! ij の内容を表示
end program para
```

**[説明]**

*   `型, parameter :: 定数名 = 値` の形式で定数を宣言します。`parameter` 属性が付いた変数は、プログラム中で値を変更することはできません。
*   配列の宣言 `ii(n, n)` のように、定数を配列の大きさ指定に使うことができます。もし配列の大きさを変更したくなった場合、`parameter` 宣言の箇所 (`n = 2` の部分) を一箇所変更するだけで、プログラム中のすべての関連する配列の大きさを変更でき、保守性が向上します。
*   `ii(:,:) = 1` は、配列 `ii` のすべての要素に `1` を代入する簡潔な方法です。`ii = 1` と書くことも可能ですが、`ii(:,:)` の方が配列全体への操作であることが明確になり、可読性が高まるため推奨されます。

---

## 4. 配列の添え字 (インデックス) の範囲指定

Fortranの配列の添え字（インデックス）は、デフォルトでは `1` から始まりますが、`:` を使って開始番号を指定することもできます。

```fortran
program array0
  implicit none

  ! 添え字が 0 から 2 までの整数型配列 a を宣言 (要素数は 3)
  integer :: a(0:2)

  a(:) = 1  ! 配列 a の全要素 (a(0), a(1), a(2)) に 1 を代入

  print*, a(0), a(1), a(2) ! 各要素を表示
end program array0
```

**[説明]**

*   `型 :: 配列名(開始インデックス : 終了インデックス)` のように宣言することで、配列のインデックス範囲を自由に設定できます。
*   例えば `integer :: b(-2:2)` と宣言すると、`b(-2), b(-1), b(0), b(1), b(2)` という5つの要素を持つ配列が作成されます。
*   これは、数学的な式や物理モデルをプログラムで表現する際に、数式の添え字とプログラムの添え字を一致させることができ、便利になる場合があります。

---

## 5. 変数の初期化

ループなどで変数に値を足し合わせていく（累算する）ような場合、ループが始まる前にその変数を適切な初期値（通常は 0）に設定しておくことが重要です。

```fortran
program initialize
  implicit none
  integer :: i, k

  k = 0  ! ★ ループで使う累算変数 k を 0 で初期化する

  do i = 1, 3
     k = k + 2 * i  ! k に 2*i を足していく (2*1 + 2*2 + 2*3)
  enddo

  print*, "k= ", k ! 計算結果 (2 + 4 + 6 = 12) を表示
end program initialize
```

**[説明]**

*   `k = 0` の初期化を行わない場合、変数 `k` にはプログラム実行開始時に不定な値（ゴミ）が入っている可能性があります。その不定な値に対して `k = k + 2 * i` の計算が行われるため、結果は意図しないものになります。
*   値を次々と足し合わせたり、掛け合わせたり（この場合は初期値1）する変数は、計算を開始する前に必ず初期化する習慣をつけましょう。配列の要素についても同様です。

---

## 6. その他の組み込み関数 (`abs`, `mod`)

Fortranには多くの便利な組み込み関数があります。第1回で紹介したものに加えて、いくつか見てみましょう。

```fortran
program func2
  implicit none
  real :: a
  integer :: k

  a = -1.5
  print*, "abs(-1.5) =", abs( a )  ! 絶対値 (absolute value)

  k = 7
  ! mod(a, b) は a を b で割った余り (modulo)
  print*, "mod(7, 3) =", mod( k, 3 )  ! 7 ÷ 3 = 2 余り 1
  print*, "mod(7, 4) =", mod( k, 4 )  ! 7 ÷ 4 = 1 余り 3
end program func2
```

**[説明]**

*   `abs(x)`: 引数 `x` の絶対値を返します。`x` が実数なら結果も実数、整数なら結果も整数です。
*   `mod(a, p)`: 整数 `a` を整数 `p` で割ったときの余りを返します。

---

## 7. ループからの脱出 (`exit`)

`do` ループの処理中に、ある条件が満たされたらループを途中で抜け出したい場合があります。その際には `exit` 文を使います。

```fortran
program exit1
  implicit none
  integer :: i

  do i = 1, 5
     print*, i
     if ( i == 2 ) exit  ! i が 2 になったらループを抜ける
  enddo
  ! exit が実行されると、ここ (enddo の次) に処理が移る

  print*, "Loop finished."

end program exit1
```

**[説明]**

*   `exit` 文が実行されると、その `exit` 文を含む最も内側の `do` ループの実行を終了し、`enddo` の次の文に処理が移ります。
*   上の例では、`i` が 1, 2 と表示された後、`i == 2` の条件が真となり `exit` が実行され、ループが終了します。`Loop finished.` が表示されます。

---

## +++ これ以下はおまけです +++

---

## 8. (おまけ) 入れ子ループからの脱出 (ラベル付き `exit`)

`do` ループが入れ子（ネスト）になっている場合、単に `exit` と書くと、一番内側のループしか抜けられません。外側のループまで一気に抜けたい場合は、ループに名前（ラベル）を付けます。

```fortran
program exit2
  implicit none
  integer :: i, j

  ! 外側のループに LOOP1 という名前(ラベル)を付ける
  LOOP1: do i = 1, 5
     ! 内側のループに LOOP2 という名前(ラベル)を付ける
     LOOP2: do j = 1, 5
        print*, i, j
        ! iが2 かつ jが2 の時、外側のループ LOOP1 を抜ける
        if ( i == 2 .and. j == 2 ) exit LOOP1
     enddo LOOP2
     ! "exit LOOP1" が実行されると、ここもスキップされる
  enddo LOOP1
  ! "exit LOOP1" が実行されると、ここに処理が移る
  print*, "Exited LOOP1"

end program exit2
```

**[説明]**

*   `ラベル名: do ... enddo ラベル名` のように、`do` 文の前と `enddo` の後に同じラベル名を付けることで、ループに名前を付けることができます。ラベル名は英数字で構成され、英字で始まる必要があります（例: `LOOP1`, `OUTER_LOOP`）。
*   `exit ラベル名` と記述することで、指定したラベル名を持つループから脱出することができます。これにより、多重ループの中から特定のループ（外側のループなど）を選択して脱出することが可能です。
*   `.and.` は論理積（AND）を表す演算子です。

**[演習]**

*   上記の `exit2` プログラムを修正し、`i == 2 .and. j == 2` の条件が満たされたときに、内側のループ (`LOOP2`) の**すぐ外**（つまり外側のループ `LOOP1` の次の繰り返し、または `LOOP1` の終了）へ出るように変更してください。（ヒント: `exit` の後のラベル名を変更するか、ラベル名を削除します。）

---

## 9. (おまけ) 配列操作関数とマスク (`sum`, `maxval` など)

Fortranには、配列全体やその一部に対して便利な操作を行う組み込み関数が多数用意されています。

```fortran
program maskmask
  implicit none
  ! 配列 k を宣言と同時に初期化 (/ ... /)
  integer :: k( 5 ) = (/ 2, 4, 999, 6, 8 /)

  ! sum(配列): 配列の全要素の合計を計算
  print*, "Sum of all elements:", sum( k )  ! 2 + 4 + 999 + 6 + 8 = 1019

  ! sum(配列, mask=条件式): 条件を満たす要素のみ合計
  ! k の要素のうち 990 より小さいものだけを合計する
  print*, "Sum where k < 990:", sum( k, mask = k < 990 ) ! 2 + 4 + 6 + 8 = 20

end program maskmask
```

**[説明]**

*   `(/ 値1, 値2, ... /)` は配列構成子とよばれ、配列を宣言と同時に初期化する簡単な方法です。
*   `sum(array)`: 配列 `array` のすべての要素の合計値を返します。
*   `sum(array, mask=logical_expression)`: 配列 `array` の要素のうち、`logical_expression` (論理式、例: `k < 990`) が真 (`.true.`) となる要素だけを合計します。この論理式を**マスク**と呼びます。
*   マスク機能は、例えばデータ中の欠損値（異常値や測定できなかった値、例では `999` をそれに見立てている）を除外して合計や平均を計算したい場合に非常に便利です。
*   他にも、配列操作関数には以下のようなものがあります（一部）。
    *   `maxval(array [, mask])`: 最大値
    *   `minval(array [, mask])`: 最小値
    *   `product(array [, mask])`: 要素の積
    *   `count(logical_expression)`: 条件を満たす要素の数
    *   `any(logical_expression)`: 条件を満たす要素が1つでもあれば `.true.`
    *   `all(logical_expression)`: すべての要素が条件を満たせば `.true.`

**[演習]**

*   上記の `maskmask` プログラムで、`sum` 関数を使っている行を `maxval` 関数に変更し、配列 `k` の要素の中で最大のものを表示するように修正してください。
*   さらに、`maxval` 関数にマスク (`mask = k < 990`) を適用し、990未満の要素の中での最大値を表示するように修正してください。
